<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <title>cl-irregsexp</title>
    <link rel="stylesheet" type="text/css" href="style.css"/>
  </head>
  
  <body>
    <div class="header">
      <h1>cl-irregsexp</h1>
      <h2>A lispy alternative to traditional regular expression syntax for
	text matching.</h2>
    </div>
    
    <h3>Introduction</h3>
    
    <p>cl-irregsexp is an ASDF-installable library for fast text
      matching. It goes beyond the facilities allowed by traditional
      regular expressions, while also making the matchers easier to
      write and maintain. </p>

    <h3>Why?</h3>

    <p>Traditional regexps are everywhere and well-understood. There are
      already <a href="http://www.cliki.net/regular expression">several
	fine regular expression toolkits for Common Lisp</a>. They are both
      complete and mature.  Why use cl-irregsexp?</p>

    <ul>
      <li>The syntax: instead of writing (with <a href="http://www.weitz.de/cl-ppcre/">cl-ppcre</a>)
	<pre>(register-groups-bind (method url version-major version-minor) 
	  ("(\\S+)\\s+(\\S+)\\s+HTTP/(\\d+).(\\d+)$" line)
	  ...)
	</pre>
	write
	<pre>(match-bind (method (+ (space)) url (+ (space)) "HTTP/" (version-major (integer)) "." (version-minor (integer)) (last))  
          line 
	  ...)</pre>
	which might be clearer and doesn't involve mentioning the
	captured variables twice.</li>
      <li>cl-irregsexp works seamlessly on both arrays of integers and on strings.</li>
      <li>cl-irregsexp has excellent performance (for some operations) using
	open-coded <a href="http://en.wikipedia.org/wiki/Boyer_-_Moore_string_search_algorithm">Boyer-Moore
	  matchers</a>.</li>
    </ul>

    <h3>Why not?</h3>

    <ul>
      <li>No documentation.</li>
      <li>The syntax is weird. For fast, complete and mature Perl
	compatible regexps check
	out <a href="http://www.weitz.de/cl-ppcre/">cl-ppcre</a> for
	example, or <a href="http://code.google.com/p/terse-ppcre/">terse-ppcre</a>.</li>
      <li>Things are still in early stages. Anything
	might change, even the name.</li>
      <li>Lack of testing and features.</li></ul>

    <h3>Help!</h3>
    <ul>
      <li>Suggest a better name!</li>
      <li>Improve the syntax.</li>
      <li>Write documentation.</li>
      <li>Add more features.</li>
    </ul>

    <p> Write to the 
      <a href="http://www.common-lisp.net/mailman/listinfo/cl-irregsexp-devel">CL-IRREGSEXP-devel</a> mailing list. Or add to the <a href="http://www.cliki.net/cl-irregsexp">wiki</a>. </p>

    <h3>Download</h3>

    <p>Here are some <a href="downloads/">snapshots</a>.</p>

    <h3>Implementation</h3>

    <P> The string matcher is generated with macros, and is completely
    inlined. It does not build a state machine (DFA) lookup table but uses
      case statements to implement the state machine in native
    code.</P>

    <P>First the matcher description is translated to an intermediate
      form with the following primitives:</P>
    <ul>
      <li>Fixed length constant string matcher. For each position in
      the string any number of characters may be accepted. For example
      the expression in traditional regexps "depot[A-Z](1|2)" is
	considered as a constant string.</li>
      <li>Finite list of choices. For example "(or (integer)
	"undefined")".</li>
      <li>Sequence of other matchers in order.</li>
      <li>Any other lisp form.</li>
    </ul>

    <P>A few transforms are applied to the intermediate form, then it
      is output as Lisp, which will hopefully be compiled to efficient native
      machine code by the Lisp environment.</P>

    <P> One particular case that has been optimised a little is that
      of searching for a constant string. The algorithm used is
      <a href="http://en.wikipedia.org/wiki/Boyer_-_Moore_string_search_algorithm">Boyer-Moore</a>, but implementation has some unusual
      facets.</P>

    <ul>
      <li>Native code generated.</li>
      <li>Does not fall back to a slow matcher if the last
	character of the needle string is matched in the
	haystack, but continues to apply the algorithm to the rest of
	the needle.</li>
      <li>Can be applied not only to simple string needles but any
	fixed length constant matcher as described above, so, for
	example, it can quickly search for a case insensitive needle.</li>
    </ul>

    <h3>Benchmark against other regex implementations</h3>

    <P>It is very irritating when people two different spellings for
    the same word. cl-irregsexp can however search for both nearly as
    fast as it can search for just one.

    <P>To demonstrate its efficiency, I chose to compare how long it
      takes to search for "indecipherable" or "undecipherable" in a long
      string, among many regex implementations.</P>

    <P>The string was one million random lowercase letters followed by
    "undecipherable". Each implementation had to read in the string to
    memory and then print out how many milliseconds it took to search
    it for the two possibilities. Just to be safe, it also has to
    print the position in the string where the word was found.

    <P>To make the test more statistically valid, most implementations
      repeat the search 1000 times and print out the average number of
      milliseconds. In this case, to make the tests comparable, the
      implementations all abort if the string is ever found at a wrong
      position.</P>

    <h4>Notes on the benchmark implementations</h4>
    
    <P>The source code for all is available in
    the <a href="downloads/">cl-irregsexp download</a> in the bench/
      directory.</P>

    <P>Ruby has the smallest and neatest benchmark program. It gets
      the award for concision. Perl has the implementation involving
      the most one character global variables. It wins the second
      prize for speed and the first prize for being impenetrable to
      language dilettantes.</P>

    <P>If you fancy sending in an example for another regexp
      implementation, I'd be pleased to add it!</P>

    <h4>Generating the test data</h4>

    <p> Here are the commands to make the data in the bash shell.
      
    <pre>$ cat /dev/urandom | tr -d -c abcdefghijklmnopqrstuvwxyz | dd bs=1 count=1000000 > test-data
$ echo undecipherable >> test-data
</pre>    

    <h3>Project members</h3>
    <pre><!--#include virtual="../../pprinted-project-members/cl-irregsexp" --></pre>

    <div class="check">
      <a href="http://validator.w3.org/check/referer">
	Valid XHTML 1.0 Strict</a>
    </div>
  </body>
</html>
